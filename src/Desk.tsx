/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from "@react-three/drei";
import { useAtom, useAtomValue } from "jotai";
import { useEffect } from "react";
import * as THREE from "three";
import type { GLTF } from "three-stdlib";
import { heldItemAtom, uniqueHeldItemsAtom } from "./Atoms";
import Book from "./Book";
import HelpText from "./HelpText";
import { Item } from "./Items";
import Pickup from "./Pickup";
import Resume from "./Resume";

type GLTFResult = GLTF & {
  nodes: {
    Shelf: THREE.Mesh;
    Coffee: THREE.Mesh;
    ColorChaos: THREE.Mesh;
    Desk: THREE.Mesh;
    Floor: THREE.Mesh;
    Bomb: THREE.Mesh;
    Coins: THREE.Mesh;
    GT: THREE.Mesh;
    Mic: THREE.Mesh;
    Cobweb: THREE.Mesh;
    GraduationCap: THREE.Mesh;
    P51: THREE.Mesh;
    B29_1: THREE.Mesh;
    B29_2: THREE.Mesh;
  };
  materials: {
    Standard: THREE.MeshStandardMaterial;
    Shiny: THREE.MeshStandardMaterial;
    WebMaterial: THREE.MeshStandardMaterial;
  };
};

const RESUME_POSITION = new THREE.Vector3(-0.343, 10.715, 4.323);
const HELP_TEXT_INITIAL = RESUME_POSITION.clone().add(
  new THREE.Vector3(5.5, 0, 0),
);
const HELP_TEXT_GOAL = HELP_TEXT_INITIAL.clone().add(
  new THREE.Vector3(2, 0, 0),
);

export function Desk(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF("/desk-transformed.glb") as GLTFResult;
  const heldItem = useAtomValue(heldItemAtom);
  const [uniqueHeldItems, setUniqueHeldItems] = useAtom(uniqueHeldItemsAtom);
  //const setItem = useSetAtom(heldItemAtom);
  // setItem(Item.Resume);

  useEffect(() => {
    if (uniqueHeldItems.indexOf(heldItem) === -1) {
      setUniqueHeldItems([...uniqueHeldItems, heldItem]);
    }
  }, [heldItem, uniqueHeldItems, setUniqueHeldItems]);

  const bookRotOffset = new THREE.Quaternion().setFromAxisAngle(
    new THREE.Vector3(1, 0, 0),
    Math.PI / 2,
  );

  return (
    <group {...props} dispose={null}>
      <group>
        {uniqueHeldItems.length === 1 && (
          <HelpText
            initialPosition={HELP_TEXT_INITIAL.toArray()}
            goalPosition={HELP_TEXT_GOAL.toArray()}
            rotation={[-Math.PI / 2, 0, 0]}
          />
        )}
        <Resume position={RESUME_POSITION} rotation={[0, 0.072, 0]} />
        <Book
          pagePath="ghevolution"
          pageCount={5}
          itemName={Item.GHEvolution}
          rotationOffset={bookRotOffset}
          position={[3.926, 10.715, 0.449]}
          rotation={[0, -0.362, 0]}
          userData={{ name: "DeskBook5" }}
        />
        <Book
          itemName={Item.YouTube}
          pagePath="youtube"
          pageCount={6}
          rotationOffset={bookRotOffset}
          position={[-5.97, 10.715, 0.498]}
          rotation={[0, 0.351, 0]}
          userData={{ name: "DeskBook3" }}
        />
        <group
          position={[-4.785, 10.715, 4.373]}
          rotation={[0, 1.197, 0]}
          scale={[0.954, 0.044, 1.377]}
          userData={{ name: "DeskBook2" }}
        />
        <group
          position={[6.048, 10.715, 3.78]}
          rotation={[0, -0.718, 0]}
          scale={[0.954, 0.044, 1.377]}
          userData={{ name: "DeskBook4" }}
        />
        <group
          position={[6.947, 14.382, -5.968]}
          rotation={[1.367, -0.02, 0.056]}
          scale={[0.954, 0.044, 1.377]}
          userData={{ name: "WebBook3" }}
        />
        <Book
          pagePath="profisee"
          pageCount={5}
          position={[0.798, 15.373, -4.713]}
          rotation={[1.386, 0, 0]}
          userData={{ name: "Web Book 1" }}
          rotationOffset={bookRotOffset}
          itemName={Item.Profisee}
        />
        <group
          position={[4.207, 13.076, -5.03]}
          rotation={[0, -1.258, 0]}
          scale={[0.954, 0.044, 1.377]}
          userData={{ name: "WebBook2" }}
        />
        <mesh
          geometry={nodes.Shelf.geometry}
          material={materials.Standard}
          position={[0.885, 11.511, -5.698]}
          scale={[13.512, 1, 1]}
          userData={{ name: "Shelf" }}
          receiveShadow
        />
        <Pickup
          position={[8.469, 11.467, 0.901]}
          rotation={[0, -0.298, 0]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(1, 0, 0),
            Math.PI / 6,
          )}
          itemName={Item.CoffeeCup}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.Coffee.geometry}
            material={materials.Standard}
            userData={{ name: "Coffee" }}
            castShadow
          />
        </Pickup>
        <Pickup
          position={[-10.167, 16.065, -4.943]}
          rotation={[1.155, -0.039, 0]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(1, 0, 0),
            Math.PI / 2,
          )}
          itemName={Item.ColorTile}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.ColorChaos.geometry}
            material={materials.Standard}
            castShadow
          />
        </Pickup>
        <mesh
          geometry={nodes.Desk.geometry}
          material={materials.Standard}
          position={[0, 10.152, 0]}
          scale={[6.748, 0.265, 6.748]}
          userData={{ name: "Desk" }}
          receiveShadow
        />
        <mesh
          geometry={nodes.Floor.geometry}
          material={materials.Standard}
          userData={{ name: "Floor" }}
        />
        <Pickup
          position={[-3.619, 15.7, -5.141]}
          rotation={[-0.794, -0.03, 1.611]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0),
            Math.PI / 2,
          )}
          itemName={Item.Bomb}
          shouldFreezeScene={true}
        >
          <mesh geometry={nodes.Bomb.geometry} material={materials.Standard} />
        </Pickup>
        <Pickup
          position={[1.866, 10.723, -5.751]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0),
            Math.PI / 2,
          )}
          itemName={Item.Coins}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.Coins.geometry}
            material={materials.Standard}
            castShadow
          />
        </Pickup>
        <Pickup
          position={[-9.535, 12.299, -5.492]}
          rotation={[1.329, 0.084, -0.326]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(1, 0, 0),
            Math.PI / 2,
          )}
          itemName={Item.GTLogo}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.GT.geometry}
            material={materials.Shiny}
            castShadow
          />
        </Pickup>
        <Pickup
          position={[-9.833, 12.304, 2.172]}
          rotation={[0, 0.522, 0]}
          itemName={Item.Mic}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.Mic.geometry}
            material={materials.Standard}
            castShadow
          />
        </Pickup>
        <Pickup
          itemName={Item.Web}
          position={[9.116, 16.957, -5.123]}
          rotation={[1.722, 0.064, 0.769]}
          rotationOffset={bookRotOffset}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.Cobweb.geometry}
            material={materials.WebMaterial}
            scale={2.003}
            castShadow
          />
        </Pickup>
        <Pickup
          position={[-3.226, 12.228, -4.529]}
          rotation={[0.189, 0.507, -0.154]}
          rotationOffset={new THREE.Quaternion().setFromAxisAngle(
            new THREE.Vector3(0, 1, 0),
            Math.PI / 6,
          )}
          itemName={Item.GraduationCap}
          shouldFreezeScene={true}
        >
          <mesh
            geometry={nodes.GraduationCap.geometry}
            material={materials.Standard}
            castShadow
          />
        </Pickup>
        <Pickup
          itemName={Item.P51}
          position={[-3.216, 18.513, -5.618]}
          rotation={[0.927, -0.501, -0.103]}
          rotationOffset={new THREE.Quaternion().setFromEuler(
            new THREE.Euler(-Math.PI / 8, Math.PI / 6, -Math.PI / 6, "XYZ"),
          )}
          shouldFreezeScene={true}
        >
          <mesh
            castShadow
            geometry={nodes.P51.geometry}
            material={materials.Shiny}
          />
        </Pickup>
        <Pickup
          itemName={Item.B29}
          position={[-6.946, 18.652, -4.764]}
          rotation={[-2.285, 0.504, -Math.PI]}
          rotationOffset={new THREE.Quaternion().setFromEuler(
            new THREE.Euler(Math.PI / 8, Math.PI, Math.PI / 6, "ZYX"),
          )}
          shouldFreezeScene={true}
        >
          <mesh
            castShadow
            geometry={nodes.B29_1.geometry}
            material={materials.Standard}
          />
          <mesh
            castShadow
            geometry={nodes.B29_2.geometry}
            material={materials.Shiny}
          />
        </Pickup>
      </group>
    </group>
  );
}

useGLTF.preload("/desk-transformed.glb");
